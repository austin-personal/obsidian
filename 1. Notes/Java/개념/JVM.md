JVM(Java Virtual Machine)은 자바 애플리케이션을 실행하기 위한 **가상 머신**으로, 다음과 같은 역할과 구조를 가집니다.
가상머신이라고 했지만 도커와는 다릅니다. 
### Docker VS JVM
- - OS 위에서 하나의 **프로세스**로 동작하며, “가상 머신”이라는 이름이 붙었지만 OS 커널을 가상화하진 않습니다.
        
    - 자바 바이트코드를 읽어서 해석(interpreter)하거나 네이티브 코드로 바꾸어(JIT 컴파일) 실행하고, 가비지 컬렉션·메모리 관리·보안 검증 같은 런타임 서비스를 제공합니다.
        
    - 결국 “자바 생태계 전체를 격리”한다기보단, “바이트코드가 어디서든 동일하게 동작하도록 해 주는 런타임”이라고 보는 게 맞습니다.

- **도커 컨테이너**
    
    - 호스트 OS 위에 독립된 유저 공간과 파일시스템, 네트워크 네임스페이스 등을 격리해서 “작은 가상 머신”처럼 띄워 줍니다.

---

## **1. JVM의 정의 및 역할**

- **정의**: 자바 바이트코드(.class 파일)를 실행할 수 있도록 설계된 가상의 컴퓨터
    
- **역할**:
    
    1. **바이트코드 해석 및 실행**
        
    2. **메모리 관리** (가비지 컬렉션)
        
    3. **플랫폼 독립성 제공** (“Write Once, Run Anywhere”)
        
    

---

## **2. JVM의 주요 구성 요소**

```
+---------------------------+
|       Class Loader       |
+---------------------------+
|   Runtime Data Areas     |
|  - Method Area           |
|  - Heap                  |
|  - Java Stack            |
|  - PC Register           |
|  - Native Method Stack   |
+---------------------------+
|     Execution Engine     |
|  - Interpreter           |
|  - JIT Compiler          |
+---------------------------+
|     Native Interface     |
+---------------------------+
|      Native Libraries    |
+---------------------------+
```

1. **클래스 로더 서브시스템 (Class Loader Subsystem)**
    
    - .class 바이트코드 파일을 읽어들여 JVM 내부 구조로 로드
        
    - **부트스트랩 로더**, **확장 로더**, **애플리케이션 로더** 계층으로 나뉨
        
    - 동적(런타임) 클래스 로딩 지원
        
    
2. **런타임 데이터 영역 (Runtime Data Areas)**
    
    - **Method Area (메서드 영역)**
        
        - 클래스 정보, 메서드 바이트코드, 상수풀, static 변수 저장
            
        
    - **Heap (힙 영역)**
        
        - 모든 객체(Object)와 배열의 인스턴스가 할당되는 영역
            
        - **가비지 컬렉터(GC)**가 주기적으로 사용하지 않는 객체 정리
            
        
    - **Java Stack (스택 영역)**
        
        - 각 스레드마다 생성, 메서드 호출 시마다 **프레임(frame)** 생성
            
        - 로컬 변수, 연산 스택, 반환 주소 등 저장
            
        
    - **PC Register (프로그램 카운터)**
        
        - 현재 실행 중인 JVM 명령(바이트코드)의 주소(위치)를 가리킴
            
        
    - **Native Method Stack (네이티브 메서드 스택)**
        
        - JNI(Java Native Interface)를 통해 호출된 네이티브(C/C++) 메서드용 스택
            
        
    
3. **실행 엔진 (Execution Engine)**
    
    - **인터프리터(Interpreter)**
        
        - 바이트코드를 한 줄씩 읽어 실행
            
        
    - **JIT(Just-In-Time) 컴파일러**
        
        - 자주 실행되는(“hot spot”) 바이트코드를 네이티브 머신 코드로 번역하여 캐싱
            
        - 이후부터는 네이티브 코드로 직접 실행 → 성능 향상
            
        
    
4. **네이티브 인터페이스 (JNI: Java Native Interface)**
    
    - 자바에서 C/C++ 등 네이티브 라이브러리를 호출할 수 있도록 연결해 주는 브릿지
        
    
5. **네이티브 라이브러리 (Native Libraries)**
    
    - 운영체제나 하드웨어 자원 접근을 위해 JNI를 통해 로드되는 플랫폼별 코드
        
    

---

## **3. JVM의 특징과 장점**

1. **플랫폼 독립성**
    
    - 바이트코드만 있으면 Windows, Linux, macOS 어디서나 동일하게 실행
        
    
2. **안정성(보안)**
    
    - 바이트코드를 실행하기 전 검증(verifier) 과정을 거쳐 잘못된 코드 차단
        
    
3. **메모리 자동 관리**
    
    - 가비지 컬렉션으로 메모리 누수 방지, 개발자는 객체 생성·소멸에만 집중
        
    
4. **성능 최적화**
    
    - JIT 컴파일러, HotSpot 최적화, 다양한 GC 알고리즘 제공
        
    

---

## **4. JVM 동작 흐름 요약**

1. 작성된 **자바 소스(.java)** → **컴파일러** → **바이트코드(.class)**
    
2. **클래스 로더**가 바이트코드 로드 → **Verifier** 검증
    
3. **Execution Engine**이 바이트코드를 인터프리트하거나 JIT 컴파일
    
4. 필요한 경우 **JNI**를 통해 네이티브 라이브러리 호출
    
5. 런타임 동안 **Heap**에 객체 할당, GC로 메모리 관리
    

---

이처럼 JVM은 자바 애플리케이션의 **플랫폼 독립 실행**, **메모리 관리**, **보안**, **성능 최적화**를 한데 묶어 제공하는 핵심 런타임 환경입니다.

# 5. **실행 흐름** - 실행 to 종료 

1. **OS 레벨에서 java 실행 파일 호출**
    
    - 터미널에서 java 커맨드를 입력하면, 운영체제가 $JAVA_HOME/bin/java(또는 PATH에 설정된 실행 파일)를 찾아 프로세스를 띄웁니다.
        
    
2. **JVM 초기화**
    
    - JVM 프로세스가 시작되면, 먼저 런타임 환경(Runtime Environment)을 초기화합니다.
        
    - 옵션(-Xmx, -classpath 등)을 파싱하고, 내부 데이터 구조(클래스 로더, 힙, 스택 등)를 할당합니다.
        
    
3. **클래스 로더에 의한 Main 클래스 로드**
    
    - 애플리케이션 클래스 로더(Application ClassLoader)가 현재 디렉터리(.)나 -classpath 로 지정된 경로에서 Main.class 파일을 찾습니다.
        
    
4. **바이트코드 검증(Bytecode Verifier)**
    
    - 로드된 Main.class의 바이트코드가 JVM 명세에 맞는지 검증하여, 악의적이거나 손상된 코드를 걸러냅니다.
        
    
5. **JIT 컴파일러 및 인터프리터 준비**
    
    - JVM은 처음에는 인터프리터 방식으로 바이트코드를 한 줄씩 실행하다가, “핫스팟(Hot Spot)”으로 판단되는 코드를 JIT(Just-In-Time) 컴파일러가 네이티브 머신 코드로 변환해 캐싱합니다.
        
    
6. **public static void main(String[] args) 호출**
    
    - JVM이 Main 클래스의 main 메서드를 찾아 호출하면서, 프로그램 로직이 시작됩니다.
        
    
7. **프로그램 종료**
    
    - main 메서드가 리턴되면, 모든 non-daemon 스레드가 종료될 때까지 기다렸다가 JVM은 정상 종료(status code 0)합니다.